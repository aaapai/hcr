[{"content":"设计模式——简单工厂模式\r1.定义\n定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的类通常都具有共同的父类。在c#中是用new新建一个类，我在unity里面用Instantiate实例化物体，addcompoent脚本组件代替（最后工厂会返回组件的实例），不然的话不继承monobehaviour是无法作为组件添加到游戏场景中的游戏对象身上的。\n2.示例\n在unity中，通过调整工厂的生产方块和圆球的方法参数，从而实例化方块和圆球，并添加方块和圆球所对应的类\n3.类图说明\nMonoBehaviour：是unity里面的类，继承于Compoent，也就是组件的一种，从而能够在场景里面通过组合的方式附加到GameObject上面 Shape:形状接口，针对接口编程，里面可以放一些业务方法，让子类实现。 Cube:方块，实现Shape接口。 Sphere:圆球，实现Shape接口。 Factory:工厂类，用于根据不同的参数（这里是name）实例化Shape预制体，再添加相应的shape脚本，比如Cube预制体就添加Cube脚本，Sphere预制体就添加Sphere脚本 1 2 3 4 5 6 7 8 9 10 public enum Name { Sphere, Cube }; public interface Shape { public abstract void Log(); } cube脚本\n1 2 3 4 5 6 7 public class Cube : MonoBehaviour,Shape { public void Log() { Debug.Log(\u0026#34;我是cube\u0026#34;); } } sphere脚本\n1 2 3 4 5 6 7 public class Sphere : MonoBehaviour,Shape { public void Log() { Debug.Log(\u0026#34;我是Sphere\u0026#34;); } } Factory脚本，简单工厂模式又叫做静态工厂模式，即工厂方法下面的这个CreateObj方法通常是静态的，然后通过点引用法去调用这个函数，在unity中的这个示例练习，我为了方便，将这里改成非静态的通过Getcommpoent直接获取这个Objfactory的实例进行方法的调用,正式场合个人觉得还是用静态的更简便。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class ObjFactory :MonoBehaviour { [SerializeField] private GameObject sphere; [SerializeField] private GameObject cube; public Shape CreateObj(Name name) { switch (name) { case Name.Sphere: return Instantiate(sphere).AddComponent\u0026lt;Sphere\u0026gt;(); case Name.Cube: return Instantiate(cube).AddComponent\u0026lt;Cube\u0026gt;(); } return null; } } FactoryClient脚本，在这个示例中，要和ObjGactory放在同一个场景中的对象上，因为这样可以获取ObjGactory的实例\n1 2 3 4 5 6 7 8 9 10 11 public class FactoryClient : MonoBehaviour { private void Update() { if (Input.GetMouseButtonDown(0)) { //ObjFactory.CreateObj(Name.Cube); this.gameObject.GetComponent\u0026lt;ObjFactory\u0026gt;().CreateObj(Name.Sphere); } } } 要点总结：\n1、unity中如果只是一些简单的数据类的工厂可以让产品不继承Monobehaviour,如果是产品要附加在场景中的GameObject上面作为组件进行交互的就要继承MonoBehaviour。\n2、在工厂类当中，如果是静态的生成产品方法，则只能调用静态的gameobject。那么既然gameobject是静态的，就不可以在检视面板赋值，要读取文件夹，获取预制体，比如这样：sphere = AssetDatabase.LoadAssetAtPath(\u0026ldquo;Assets/Prefabs/sphere.prefab\u0026rdquo;);\n3、为了简化简单工厂模式，可以把产品的抽象父类或者接口和工厂类合并，把静态工厂方法转移到抽象产品那里，直接又是产品又是工厂。在unity中，产品如果要附加MonoBehaviour的话就必须用接口，而不能用抽象父类，所以没有方法体，这种方式无法使用，但是不继承monobehaviour的就可以用。\n4、工厂类负责创建的对象比较少不会造成工厂方法中的业务太复杂，客户端只知道传入工厂类的参数对如何创建不关心的时候可以考虑用简单工厂模式。\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/p/unity07/","title":"C#_设计模式——简单工厂模式（非二十三种设计模式）"},{"content":"设计模式——观察模式\r1.定义\n定义对象之间的一种一对多的依赖关系，使得每当一个对象状态发生改变时其相关依赖对象皆得到通知，并被自动更新\n2.示例 在某多人联机对战游戏中，多个玩家可以加入同一战队组成联盟，当战队中的某一成员受到敌人攻击时将给所有其他盟友发送通知，盟友收到通知后将做出响应\n3.类图说明 AbsContorlCenter：抽象控制中心，也就是被观察者，包含AbsPlayer的引用。一个遍历player引用进而通知player的方法，还有玩家add,remove进list的方法 ContorlCenter:具体控制中心，被观察者的一部分，实现抽象控制中心的方法。 AbsPlayer:抽象玩家，也就是观察者，包含AbsContorlCenter的引用。一个被攻击的方法，一个收到盟友被攻击的方法。 Player:具体玩家，也是观察者的一部分。包括一个构造函数，new的时候赋予名字。当player被攻击的时候，调用自己的被攻击的方法，从而调用调用控制中心的Notify方法。盟友收到控制中心发来的Notify方法之后，做出反应调用Update方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace observer { public abstract class AbsControlCenter { public string name; public List\u0026lt;AbsPlayer\u0026gt; playerList; public abstract void Notify(); public abstract void Add(AbsPlayer player); public abstract void Remove(AbsPlayer player); } public class ControlCenter : AbsControlCenter { public ControlCenter(string name) { playerList = new List\u0026lt;AbsPlayer\u0026gt;(); this.name = name; } public override void Add(AbsPlayer Player) { playerList.Add(Player); } public override void Notify() { foreach(AbsPlayer ts in playerList) { ts.Update(); } } public override void Remove(AbsPlayer player) { foreach(AbsPlayer ts in playerList) { if (ts.Equals(player)) { playerList.Remove(player); return; } } } } public abstract class AbsPlayer { public string name; public ControlCenter controlCenter; public abstract void Update(); public abstract void BeAttacked(AbsControlCenter absControlCenter); } public class Player : AbsPlayer { public Player(string name) { this.name = name; } public override void BeAttacked(AbsControlCenter controlCenter) { Console.WriteLine(name + \u0026#34;被攻击了\u0026#34;); controlCenter?.Notify(); } public override void Update() { Console.WriteLine(\u0026#34;我来帮你了：\u0026#34;+ name); } } class Program { public static Random id = new Random(); static void Main(string[] args) { AbsControlCenter absControlCenter = new ControlCenter(\u0026#34;虚拟现实技术班级\u0026#34;); AbsPlayer absPlayer = new Player(\u0026#34;小刘\u0026#34;); AbsPlayer absPlayer1 = new Player(\u0026#34;小黄\u0026#34;); AbsPlayer absPlayer2 = new Player(\u0026#34;小李\u0026#34;); absControlCenter.Add(absPlayer); absControlCenter.Add(absPlayer1); absControlCenter.Add(absPlayer2); absPlayer.BeAttacked(absControlCenter); Console.ReadLine(); } } } 输出内容：\n小刘被攻击了\n我来帮你了：小黄\n我来帮你了：小李\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/p/unity06/","title":"C#_设计模式——观察模式"},{"content":"设计模式序章\r设计模式七大原则\n设计模式原则 定义 开闭原则 对拓展开放，对修改关闭。程序功能的拓展可以在不修改原有代码的情况下进行 单一职责原则 一个类只负责一个功能领域中的相应职责。在unity里面一个脚本只完成一件事情 里氏替换原则 所有引用基类的地方必须能透明地使用其子类的对象。子类可以替换父类而不影响程序 接口隔离原则 不应该强迫客户依赖于他们不适用的接口。把接口拆分成小而具体的接口，客户只依赖需要使用的方法 依赖倒置原则 高层模块不应该依赖底层模块，都应该依赖其抽象。面向抽象编程 迪米特法则 一个对象应该尽可能少地了解其他对象。就是某个对象与其他对象的交互仅限于与其直接朋友之间的交互 复合/聚合复用原则 尽量使用组合或聚合的方式，而不是使用继承来复用。这样可以更灵活的创建对象之间的关系，并有助于保持系统的灵活性和可维护性 23种设计模式\n创建型模式 结构性模式 行为型模式 工厂方法模式 抽象工厂模式 建造者模式 原型模式 单例模式 适配器模式 桥接模式 组合模式 装饰模式 外观模式 享元模式 代理模式 解释器模式 模板方法模式 职责链模式 命令模式 迭代器模式 中介者模式 备忘录模式 观察者模式 状态模式 策略模式 访问者模式 ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/p/unity05/","title":"C#_设计模式序章"},{"content":"变量\r变量包括引用类型和值类型\r1.内存分配：\n值类型的变量直接存储数据，通常分配在栈上，栈内存的分配和释放速度较快，适合存储较小的数据\n引用类型的变量存储的是对象的引用（内存地址），而实际上数据存储在堆上，堆内存的分配和释放速度较慢，适合存储大量的数据。 2.生命周期\n值类型的变量在使用完毕后会被自动回收，而引用类型的变量需要垃圾回收机制（GC）来管理内存。 3.装箱与拆箱\n装箱：将值类型转换为引用类型。装箱会创建一个新的对象，并将值类型的数据复制到该对象中。\n拆箱：将引用类型转换为值类型。拆箱会从对象中复制数据到值类型变量中。拆箱需要显式类型转换 4.类型举例\n值类型：int float bool char double struct enum等，默认值不为空\n引用类型：class string interface delegate array等，默认值为null 类型总结\r值类型：直接存储数据，分配在栈上，赋值时创建副本，性能好 引用类型：存储对象引用，分配在堆上，赋值时共享引用，性能差，需要GC管理内存，适合存储大量的数据。 变量作用域\r变量的作用域通常由花括号{}决定，在if、for、方法等代码块内声明的是局部变量只在声明他们的代码块中可见 静态变量是类级别上声明的整个类中可见\n小补充1：对于值类型如果要让他可空(默认值为空)，直接在类型后加一个?即可\r1 int? i; 小补充2：？？Null合并运算符\r1 2 //假如num为空则返回23给a，非空则返回num给a int a=num??23; ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/p/unity01/","title":"C#语法_变量"},{"content":"委托类型：存有方法的引用，派生自system.Dlegate\r声明：访问修饰符 delegate 返回类型 委托名(参数列表); 赋值：委托类型 委托实例名=new 委托类型(方法名); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public delegate void num(string s); //static num ps1 = new num(Program.output); //或者 static num ps1 =Program.Output; static void Main(string[] args) { ps1+=OutputDouble; ps1.Invoke(\u0026#34;aaa\u0026#34;); Program.ps1 -= output; ps1?.Invoke(\u0026#34;bbb\u0026#34;); Console.ReadLine(); } static void Output(string s) { Console.WriteLine(s); } static void OutputDouble(string s) { Console.WriteLine(s+s); } 事件\r*声明：访问修饰符 event 委托类型 事件名；\n使用事件有三个步骤：定义事件、订阅事件和触发事件。\n1.定义事件：\n定义事件需要一个事先定义一个委托类型来指定事件处理方法的签名；\n对于不需要传递额外信息的简单事件，可以直接使用.net提供的EventHandler委托 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 using System; public class Publisher { // 基于预定义的EventHandler定义事件 public event EventHandler SomethingHappened; protected virtual void OnSomethingHappened() { // 检查是否有订阅者 SomethingHappened?.Invoke(this, EventArgs.Empty); } public void DoSomething() { // 执行一些操作... Console.WriteLine(\u0026#34;Publisher is doing something...\u0026#34;); // 触发事件 OnSomethingHappened(); } } 如果需要传递自定义数据，可以创建继承自EventArgs的新类，并使用泛型版本的EventHandler：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class CustomEventArgs : EventArgs { public string Message { get; set; } public CustomEventArgs(string message) { Message = message; } } public class Publisher { // 使用自定义EventArgs定义事件 public event EventHandler\u0026lt;CustomEventArgs\u0026gt; SomethingHappened; protected virtual void OnSomethingHappened(CustomEventArgs e) { SomethingHappened?.Invoke(this, e); } public void DoSomething() { Console.WriteLine(\u0026#34;Publisher is doing something...\u0026#34;); OnSomethingHappened(new CustomEventArgs(\u0026#34;A custom message\u0026#34;)); } } 2.订阅事件\n订阅事件就是注册一个当事件发生时应该执行的方法。用+=运算符完成比较方便： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class Subscriber { public Subscriber(Publisher publisher) { // 订阅事件 publisher.SomethingHappened += HandleSomethingHappened; } private void HandleSomethingHappened(object sender, EventArgs e) { if (e is CustomEventArgs customEventArgs) { Console.WriteLine($\u0026#34;Received message: {customEventArgs.Message}\u0026#34;); } else { Console.WriteLine(\u0026#34;Event received!\u0026#34;); } } } 3.触发事件\n事件由发布者触发。例如，在上述例子中，Publisher类中的DoSomething方法会在适当时候调用OnSomethingHappened方法来触发事件： 1 2 3 4 5 6 7 8 9 10 11 12 class Program { static void Main(string[] args) { var publisher = new Publisher(); var subscriber = new Subscriber(publisher); publisher.DoSomething(); Console.ReadKey(); } } C#的Action\r1 2 3 4 5 6 7 8 namespace System { // // 摘要: // 封装一个方法，该方法不具有参数且不返回值。 [TypeForwardedFrom(\u0026#34;System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089\u0026#34;)] public delegate void Action(); } C#的Action泛型版本\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 namespace System { // // 摘要: // 封装一个方法，该方法只有一个参数并且不返回值。 若要浏览此类型的.NET Framework 源代码，请参阅Reference Source。 // // 参数: // obj: // 此委托封装的方法的参数。 // // 类型参数: // T: // 此委托封装的方法的参数类型。 public delegate void Action\u0026lt;in T\u0026gt;(T obj); } C#的Func\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 namespace System { //这个是fun的十六个重载中的一个参数一个返回值的泛型重载 // 摘要: // 封装一个方法，该方法具有一个参数，且返回由 TResult 参数指定的类型的值。 若要浏览此类型的.NET Framework 源代码，请参阅Reference // Source。 // // 参数: // arg: // 此委托封装的方法的参数。 // // 类型参数: // T: // 此委托封装的方法的参数类型。 // // TResult: // 此委托封装的方法的返回值类型。 // // 返回结果: // 此委托封装的方法的返回值。 [TypeForwardedFrom(\u0026#34;System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089\u0026#34;)] public delegate TResult Func\u0026lt;in T, out TResult\u0026gt;(T arg); } 这两个都是委托。如果要使用的方法有参数的话，就选择不同的个数的重载，参数可以选择0个到16个\nAction Func\u0026lt;\u0026gt; 封装的方法，无返回值 封装的方法，有返回值 unity里面的Action和Func\u0026lt;\u0026gt;，参数最多四个\nUnityAction UnityFunc\u0026lt;\u0026gt; 封装的方法，无返回值 封装的方法，有返回值 小拓展：UnityEvent和Event,unity魔改过后的好处是unity将其序列化了，在检视面板可视化编辑\nunityEvent和C#Event对比\nUnityAction和C#Action对比\nC#的EventArgs\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 namespace System { // // 摘要: // 表示包含事件数据的类的基类，并提供用于不包含事件数据的事件的值。 [ComVisible(true)] public class EventArgs { // // 摘要: // 提供用于与不包含事件数据的事件的值。 public static readonly EventArgs Empty; // // 摘要: // 初始化 System.EventArgs 类的新实例。 public EventArgs(); } } C#的EventHandler\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 namespace System { // // 摘要: // 表示将用于处理不具有事件数据的事件的方法。 // // 参数: // sender: // 事件源。 // // e: // 不包含事件数据的对象。 [ComVisible(true)] public delegate void EventHandler(object sender, EventArgs e); } ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/p/unity04/","title":"C#语法_委托与事件"},{"content":"方法\r结构： 访问修饰符 返回类型 函数名(参数列表){代码块} 1 2 3 4 public int GetName(int a){ a++; return a; } 参数列表用于传输参数，其中包括值参数传递、引用参数传递（ref）、输出型参数传递（out）。默认为值传递，实参和形参不同内存，所以不会影响原始变量。ref参数和out参数，允许方法修改传递给他的参数，并使这些修改反映到调用方法中的原始变量。\nref参数 out参数 ref倾向于修改已有的值 out主要用于从方法内部输出一个的值 以引用传递参数,参数值改变则原始值也改变。使用前必须赋值（形参改了实参也改） 方法体内部必须对out参数赋值，传递之前不用赋值，赋值了也会被忽略 ref参数\n1 2 3 4 5 6 7 8 9 static void ModifyValue(ref int number) { number += 10; } // 调用代码 int myNumber = 5; ModifyValue(ref myNumber); // 此时myNumber为15 out参数\n1 2 3 4 5 6 7 8 9 static void GetValue(out int number) { number = 20; // 必须赋值 } // 调用代码 int myNumber; GetValue(out myNumber); // 此时myNumber为20 递归：\n要素：1.退出条件 2.递归步骤，大化小 1 2 3 4 5 6 7 8 9 public static int Factorial(int n) { // 退出条件 if (n == 0) return 1; else // 递归步骤 return n * Factorial(n - 1); } ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/p/unity03/","title":"C#语法_方法"},{"content":"访问修饰符\rpublic:在所有地方都可以访问，没有访问限制 private:在类内部可以访问 protected:在类内部以及派生类访问 internal:在程序集内部访问，同一个程序时相当于public protected internal 封装\r封装是一种面向对象编程的基本概念，将数据和操作数据的方法绑定在一起，并通过访问修饰符控制对类成员的访问。 例如，将字段声明为private，并提供public方法或属性来间接访问这些字段。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Person { private string name; //法一 public string Name { get { return name; } set { if (!string.IsNullOrEmpty(value)) name = value; else throw new ArgumentException(\u0026#34;Name cannot be null or empty\u0026#34;); } } //法二 public string GetName() { return name; } } ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/p/unity02/","title":"C#语法_访问修饰符和封装"}]