[{"content":"变量\r变量包括引用类型和值类型\r1.内存分配：\n值类型的变量直接存储数据，通常分配在栈上，栈内存的分配和释放速度较快，适合存储较小的数据\n引用类型的变量存储的是对象的引用（内存地址），而实际上数据存储在堆上，堆内存的分配和释放速度较慢，适合存储大量的数据。 2.生命周期\n值类型的变量在使用完毕后会被自动回收，而引用类型的变量需要垃圾回收机制（GC）来管理内存。 3.装箱与拆箱\n装箱：将值类型转换为引用类型。装箱会创建一个新的对象，并将值类型的数据复制到该对象中。\n拆箱：将引用类型转换为值类型。拆箱会从对象中复制数据到值类型变量中。拆箱需要显式类型转换 4.类型举例\n值类型：int float bool char double struct enum等，默认值不为空\n引用类型：class string interface delegate array等，默认值为null 类型总结\r值类型：直接存储数据，分配在栈上，赋值时创建副本，性能好 引用类型：存储对象引用，分配在堆上，赋值时共享引用，性能差，需要GC管理内存，适合存储大量的数据。 变量作用域\r变量的作用域通常由花括号{}决定，在if、for、方法等代码块内声明的是局部变量只在声明他们的代码块中可见 静态变量是类级别上声明的整个类中可见\n小补充1：对于值类型如果要让他可空(默认值为空)，直接在类型后加一个?即可\r1 int? i; 小补充2：？？Null合并运算符\r1 2 //假如num为空则返回23给a，非空则返回num给a int a=num??23; ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/p/unity01/","title":"C#语法_变量"},{"content":"方法\r结构： 访问修饰符 返回类型 函数名(参数列表){代码块} 1 2 3 4 public int GetName(int a){ a++; return a; } 参数列表用于传输参数，其中包括值参数传递、引用参数传递（ref）、输出型参数传递（out）。默认为值传递，实参和形参不同内存，所以不会影响原始变量。ref参数和out参数，允许方法修改传递给他的参数，并使这些修改反映到调用方法中的原始变量。\nref参数 out参数 ref倾向于修改已有的值 out主要用于从方法内部输出一个的值 以引用传递参数,参数值改变则原始值也改变。使用前必须赋值（形参改了实参也改） 方法体内部必须对out参数赋值，传递之前不用赋值，赋值了也会被忽略 ref参数\n1 2 3 4 5 6 7 8 9 static void ModifyValue(ref int number) { number += 10; } // 调用代码 int myNumber = 5; ModifyValue(ref myNumber); // 此时myNumber为15 out参数\n1 2 3 4 5 6 7 8 9 static void GetValue(out int number) { number = 20; // 必须赋值 } // 调用代码 int myNumber; GetValue(out myNumber); // 此时myNumber为20 递归：\n要素：1.退出条件 2.递归步骤，大化小 1 2 3 4 5 6 7 8 9 public static int Factorial(int n) { // 退出条件 if (n == 0) return 1; else // 递归步骤 return n * Factorial(n - 1); } ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/p/unity03/","title":"C#语法_方法"},{"content":"方法\r","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/p/unity04/","title":"C#语法_结构体和枚举"},{"content":"访问修饰符\rpublic:在所有地方都可以访问，没有访问限制 private:在类内部可以访问 protected:在类内部以及派生类访问 internal:在程序集内部访问，同一个程序时相当于public protected internal 封装\r封装是一种面向对象编程的基本概念，将数据和操作数据的方法绑定在一起，并通过访问修饰符控制对类成员的访问。 例如，将字段声明为private，并提供public方法或属性来间接访问这些字段。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Person { private string name; //法一 public string Name { get { return name; } set { if (!string.IsNullOrEmpty(value)) name = value; else throw new ArgumentException(\u0026#34;Name cannot be null or empty\u0026#34;); } } //法二 public string GetName() { return name; } } ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/p/unity02/","title":"C#语法_访问修饰符和封装"}]